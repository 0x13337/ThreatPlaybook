{"_default": {"1": {"name": "Plaintext transmission of sensitive data", "description": "The software transmits sensitive or security-critical data in cleartext in a communication channel that can be sniffed by unauthorized actors.", "categories": ["app_vulns", "owasp"], "mitigations": [{"phase": "Architecture and Design", "description": "Encrypt the data with a reliable encryption scheme before transmitting."}, {"phase": "Implementation", "description": "When using web applications with SSL, use SSL for the entire session from login to logout, not just for the initial login page."}, {"phase": "Testing", "description": "Use tools and techniques that require manual (human) analysis, such as penetration testing, threat modeling, and interactive tools that allow the tester to record and modify an active session. These may be more effective than strictly automated techniques. This is especially the case with weaknesses that are related to design and business rules."}, {"phase": "Operation", "description": "Configure servers to use encrypted channels for communication, which may include SSL or other secure protocols."}], "test-cases": [{"test": "Check for SSL/TLS implementation with automated tools", "tools": ["ssllabs.com", "testssl.sh", "sslyze", "sslscan", "nmap"], "type": "discovery", "name": "ssl-test"}, {"test": "Run Source Composition Scanners against the libraries being used by the application, to identify instances of misconfigured SSL/TLS Implementation or Plaintext Data Transmission", "tools": ["retirejs", "npm-audit", "owasp-dependency-checker", "blackduck", "whitesource", "snyk", "safety"], "type": "sca", "name": "source-composition-scanning"}, {"test": "Run Static Analysis tools to identify instances that relate to misconfigured SSL/TLS Implementation or Plaintext Data Transmission", "tools": ["checkmarx", "brakeman", "bandit", "pyt", "security-code-scan", "veracode", "nodejsscan", "coverity"], "type": "sast", "name": "static-analysis"}], "cwe": 319, "related_cwes": [311], "risk": [{"consequence": "Anyone can read the information by gaining access to the channel being used for communication.", "type": "Confidentiality"}]}, "2": {"mitigations": [{"phase": "Implementation", "description": "Ensure that IAM Policies are set for AWS S3 to protect against public/unauthorized access to unauthorized users"}, {"phase": "Implementation", "description": "Consider implementation of encryption for data stored in AWS S3"}], "risk": [{"consequence": "Unauthorized Users may gain access to files with sensitive information in the AWS S3 bucket(s)", "type": "Confidentiality"}, {"consequence": "Unauthorized Users may write/modify data in the AWS S3 bucket(s)", "type": "Integrity"}], "name": "Misconfigured AWS S3 Bucket", "categories": ["cloud"], "cwe": 16, "test-cases": [{"test": "run automated vulnerability discovery tools to identify misconfigured AWS S3 buckets", "type": "discovery", "tools": ["scout2", "prowler", "weirdaal", "burpsuite"], "name": "automated-vulnerability-scanning"}, {"test": "test for misconfigured AWS S3 Buckets manually, as part of a Pentest or Bug-bounty", "type": "manual", "name": "manual"}], "description": "Misconfigured Amazon AWS S3 Bucket(s) might allow unauthorized users to read/write files in the specific S3 buckets"}, "3": {"test-cases": [{"test": "run automated vulnerability discovery tools and bruteforce against the application", "tools": ["zap", "burpsuite", "arachni", "acunetix", "netsparker", "appspider", "w3af"], "type": "discovery", "name": "automated-vulnerability-scanning"}], "mitigations": [{"phase": "Architecture and Design", "description": "Ensure that users are locked out for a certain timeframe/till administrator's intervention when multiple authentication attempts are encountered."}, {"phase": "Architecture and Design", "description": "Log invalid access attempts to ensure that potentially malicious bruteforce attempts are logged"}], "name": "Bruteforce Passwords", "cwe": 307, "categories": ["attack"], "description": "The application allows multiple/consecutive attempts at authentication (bruteforce)."}, "4": {"name": "SQL Injection", "risk": [{"consequence": "Since SQL databases generally hold sensitive data, loss of confidentiality is a frequent problem with SQL injection vulnerabilities.", "type": "Confidentiality"}, {"consequence": "If poor SQL commands are used to check user names and passwords, it may be possible to connect to a system as another user with no previous knowledge of the password.", "type": "Access_Control"}, {"consequence": "If authorization information is held in a SQL database, it may be possible to change this information through the successful exploitation of a SQL injection vulnerability.", "type": "Access_Control"}, {"consequence": "Just as it may be possible to read sensitive information, it is also possible to make changes or even delete this information with a SQL injection attack.", "type": "Integrity"}], "mitigations": [{"phase": "Architecture and Design", "description": "Consider using ORMs (Object to Relation Mappers) to protect against SQL Injection. Nearly all of them perform Parameterized Queries and Query Encoding.", "strategy": "Libraries or Frameworks"}, {"phase": "Implementation", "description": "Process SQL queries using prepared statements, parameterized queries. Do not dynamically construct and execute query strings within these features using \"exec\" or similar functionality, since this may re-introduce the possibility of SQL injection."}, {"phase": "Architecture and Design", "description": "Specifically, follow the principle of least privilege when creating user accounts to a SQL database. The database users should only have the minimum privileges necessary to use their account."}, {"phase": "Implementation", "description": "In the context of SQL Injection, error messages revealing the structure of a SQL query can help attackers tailor successful attack strings."}, {"phase": "Operation", "description": "Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed,as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth."}], "categories": ["app_vulns", "owasp"], "variants": ["Blind SQL Injection", "Time-Based SQL Injection", "Union-Based SQL Injection", "Error-Based SQL Injection", "Second-Order SQL Injection"], "cwe": 89, "test-cases": [{"test": "run automated vulnerability discovery tools and its Injection payloads against the application", "type": "discovery", "tools": ["zap", "burpsuite", "arachni", "acunetix", "netsparker", "appspider", "w3af"], "name": "automated-vulnerability-scanning"}, {"test": "test for SQL Injection variants manually with pentesters, bug-bounty", "type": "manual", "name": "manual"}, {"test": "Run exploit tools to identify and exploit SQL Injections in the application", "tools": ["sqlmap", "netsparker", "jsqli"], "type": "exploit", "name": "exploit"}, {"test": "Run Source Composition Scanners against the libraries being used by the application, to identify instances of SQL Injection", "type": "sca", "tools": ["retirejs", "npm-audit", "owasp-dependency-checker", "blackduck", "whitesource", "snyk", "safety"], "name": "source-composition-scanning"}, {"test": "Run Static Analysis tools to identify instances of dynamic queries or stored procedures that are vulnerable to SQL Injection", "type": "sast", "tools": ["checkmarx", "brakeman", "bandit", "pyt", "security-code-scan", "veracode", "nodejsscan", "coverity"], "name": "static-analysis"}], "description": "The software constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component."}, "5": {"mitigations": [{"phase": "Architecture and Design", "description": "If available, use the signing/sealing features of the programming language to assure that deserialized data has not been tainted. For example, a hash-based message authentication code (HMAC) could be used to ensure that data has not been modified."}, {"phase": "Implementation", "description": "When deserializing data, populate a new object rather than just deserializing. The result is that the data flows through safe input validation and that the functions are safe."}, {"phase": "Architecture and Design", "description": "An attempt to serialize and then deserialize a class containing transient fields will result in NULLs where the transient data should be. This is an excellent way to prevent time, environment-based, or sensitive variables from being carried over and used improperly."}, {"phase": "Implementation", "description": "Avoid having unnecessary types or gadgets available that can be leveraged for malicious ends. This limits the potential for unintended or unauthorized types and gadgets to be leveraged by the attacker. Whitelist acceptable classes. Note- new gadgets are constantly being discovered, so this alone is not a sufficient mitigation."}], "name": "Insecure Deserialization", "categories": ["app_vulns", "owasp"], "description": "The application deserializes untrusted data without sufficiently verifying that the resulting data will be valid.", "cwe": 502, "test-cases": [{"test": "run automated vulnerability discovery tools and its Insecure Deserialization payloads against the application", "tools": ["zap", "burpsuite", "arachni", "acunetix", "netsparker", "appspider", "w3af"], "type": "discovery", "name": "automated-vulnerability-scanning"}, {"test": "test for Insecure Deserialization variants manually with pentesters, bug-bounty", "type": "manual", "name": "manual"}, {"test": "Run Static Analysis tools to identify instances of improper input validation and output encoding for Insecure Deserialization", "tools": ["checkmarx", "brakeman", "bandit", "pyt", "security-code-scan", "veracode", "nodejsscan", "coverity"], "type": "sast", "name": "static-analysis"}, {"test": "Run Source Composition Scanners against the libraries being used by the application, to identify instances of Insecure Deserialization", "tools": ["retirejs", "npm-audit", "owasp-dependency-checker", "blackduck", "whitesource", "snyk", "safety"], "type": "sca", "name": "source-composition-scanning"}], "risk": [{"consequence": "The consequences can vary widely, because it depends on which objects or methods are being deserialized, and how they are used."}, {"consequence": "Attackers can modify unexpected objects or data that was assumed to be safe from modification.", "type": "Integrity"}, {"consequence": "If a function is making an assumption on when to terminate, based on a sentry in a string, it could easily never terminate.", "type": "Availability"}, {"consequence": "Code could potentially make the assumption that information in the deserialized object is valid. Functions that make this dangerous assumption could be exploited.", "type": "Authorization"}]}, "6": {"test-cases": [{"test": "run automated vulnerability discovery tools and its XXE payloads against the application", "type": "discovery", "tools": ["zap", "burpsuite", "arachni", "acunetix", "netsparker", "appspider", "w3af"], "name": "automated-vulnerability-scanning"}, {"test": "test for XXE variants manually with pentesters, bug-bounty", "type": "manual", "name": "manual"}, {"test": "Run Source Composition Scanners against the libraries being used by the application, to identify instances of XXE", "type": "sca", "tools": ["retirejs", "npm-audit", "owasp-dependency-checker", "blackduck", "whitesource", "snyk", "safety"], "name": "source-composition-scanning"}, {"test": "Run Static Analysis tools to identify instances of dynamic queries or stored procedures that are vulnerable to XXE", "type": "sast", "tools": ["checkmarx", "brakeman", "bandit", "pyt", "security-code-scan", "veracode", "nodejsscan", "coverity"], "name": "static-analysis"}], "mitigations": [{"phase": "Implementation", "description": "XML parsers and validators must be configured to disable external entity expansion, general entities and parameter entity resolution"}], "name": "XML External Entities", "description": "The software processes an XML document that can contain XML entities with URIs that resolve to documents outside of the intended sphere of control, causing the product to embed incorrect documents into its output.", "cwe": 611, "categories": ["app_vulns", "owasp"], "risk": [{"consequence": "If the attacker is able to include a crafted DTD and a default entity resolver is enabled, the attacker may be able to access arbitrary files on the system.", "type": "Confidentiality"}, {"consequence": "The DTD may include arbitrary HTTP requests that the server may execute. This could lead to other attacks leveraging the server's trust relationship with other entities.", "type": "Integrity"}, {"consequence": "The software could consume excessive CPU cycles or memory using a URI that points to a large file, or a device that always returns data such as /dev/random. Alternately, the URI could reference a file that contains many nested or recursive entity references to further slow down parsing.", "type": "Availability"}]}, "7": {"name": "Code Injection", "description": "The software constructs all or part of a code segment using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the syntax or behavior of the intended code segment.", "categories": ["app_vulns", "owasp"], "mitigations": [{"phase": "Architecture and Design", "description": "Refactor your program so that you do not have to dynamically generate code."}, {"phase": "Implementation", "description": "To reduce the likelihood of code injection, use stringent whitelists that limit which constructs are allowed. If you are dynamically constructing code that invokes a function, then verifying that the input is alphanumeric might be insufficient. An attacker might still be able to reference a dangerous function that you did not intend to allow, such as system(), exec(), or exit()."}, {"phase": "Testing", "description": "Use automated static analysis tools that target this type of weakness. Many modern techniques use data flow analysis to minimize the number of false positives. This is not a perfect solution, since 100% accuracy and coverage are not feasible."}, {"phase": "Testing", "description": "Use dynamic tools and techniques that interact with the software using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The software's operation may slow down, but it should not become unstable, crash, or generate incorrect results."}, {"phase": "Operation", "description": "Run the code in an environment that performs automatic taint propagation and prevents any command execution that uses tainted variables, such as Perl's \"-T\" switch. This will force the program to perform validation steps that remove the taint, although you must be careful to correctly validate your inputs so that you do not accidentally mark dangerous inputs as untainted (see CWE-183 and CWE-184)."}, {"phase": "Testing", "description": "Identify vulnerabilities in underlying libraries with Source Composition Scanning"}, {"phase": "Implementation", "description": "Consider using low-logic templating systems, if you are using Templating Frameworks. Low-Logic Templating Systems like Mustache cannot expand objects and data-structures, thereby ensuring that remote code execution through Template Variables, does not happen"}], "test-cases": [{"test": "run automated vulnerability discovery tools and its Injection payloads against the application", "tools": ["zap", "burpsuite", "arachni", "acunetix", "netsparker", "appspider", "w3af"], "type": "discovery", "name": "automated-vulnerability-scanning"}, {"test": "test for Code Injection variants manually with pentesters, bug-bounty", "type": "manual", "name": "manual"}, {"test": "Run exploit tools to identify and exploit Code Injections in the application", "type": "exploit", "tools": ["sqlmap", "netsparker", "jsqli"], "name": "exploit"}, {"test": "Run Source Composition Scanners against the libraries being used by the application, to identify instances of Code Injection", "tools": ["retirejs", "npm-audit", "owasp-dependency-checker", "blackduck", "whitesource", "snyk", "safety"], "type": "sca", "name": "source-composition-scanning"}, {"test": "Run Static Analysis tools to identify instances of dynamic queries or stored procedures that are vulnerable to Code Injection", "tools": ["checkmarx", "brakeman", "bandit", "pyt", "security-code-scan", "veracode", "nodejsscan", "coverity"], "type": "sast", "name": "static-analysis"}], "variants": ["Server-Side Eval Injection", "Server-Side Template Injection"], "cwe": 94, "related_cwes": [95, 96], "risk": [{"consequence": "In some cases, injectable code controls authentication; this may lead to a remote vulnerability.", "type": "Access_Control"}, {"consequence": "Injected code can access resources that the attacker is directly prevented from accessing.", "type": "Access_Control"}, {"consequence": "Code injection attacks can lead to loss of data integrity in nearly all cases as the control-plane data injected is always incidental to data recall or writing. Additionally, code injection can often result in the execution of arbitrary code.", "type": "Integrity"}, {"consequence": "Often the actions performed by injected control code are unlogged.", "type": "Non-Repudiation"}]}, "8": {"name": "Cross-Site Scripting", "description": "The software does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.", "test-cases": [{"test": "run automated vulnerability discovery tools and its XSS payloads against the application", "type": "discovery", "tools": ["zap", "burpsuite", "arachni", "acunetix", "netsparker", "appspider", "w3af"], "name": "automated-vulnerability-scanning"}, {"test": "test for XSS variants manually with pentesters, bug-bounty", "type": "manual", "name": "manual"}, {"test": "Look for Content Security Policy headers in the Application and validate if the application enforces content-security-policy headers with optimal efficacy", "type": "recon", "name": "content-security-policy"}, {"test": "Look for Cross-Origin Resource Sharing to ensure that the application is unable to make calls to URLs outside a specific set of whitelisted URLs and domains", "type": "discovery", "name": "cors"}, {"test": "Run Static Analysis tools to identify instances of improper input validation and output encoding for Cross-Site Scripting", "type": "sast", "tools": ["checkmarx", "brakeman", "bandit", "pyt", "security-code-scan", "veracode", "nodejsscan", "coverity"], "name": "static-analysis"}, {"test": "Run Source Composition Scanners against the libraries being used by the application, to identify instances of Cross-Site Scripting", "type": "sca", "tools": ["retirejs", "npm-audit", "owasp-dependency-checker", "blackduck", "whitesource", "snyk", "safety"], "name": "source-composition-scanning"}], "mitigations": [{"phase": "Architecture and Design", "description": "Examples of libraries and frameworks that make it easier to generate properly encoded output include Microsoft's Anti-XSS library, the OWASP ESAPI Encoding module, and Apache Wicket."}, {"phase": "Architecture and Design", "description": "Understand all the potential areas where untrusted inputs can enter your software. Parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, filenames, databases, and any external systems that provide data to the application. Remember that such inputs may be obtained indirectly through API calls."}, {"phase": "Architecture and Design", "description": "For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side."}, {"phase": "Architecture and Design", "description": "If available, use structured mechanisms that automatically enforce the separation between data and code. These mechanisms may be able to provide the relevant quoting, encoding, and validation automatically, instead of relying on the developer to provide this capability at every point where output is generated."}, {"phase": "Implementation", "description": "The problem of inconsistent output encodings often arises in web pages. If an encoding is not specified in an HTTP header, web browsers often guess about which encoding is being used. This can open up the browser to subtle XSS attacks."}, {"phase": "Implementation", "description": "To help mitigate XSS attacks against the user's session cookie, set the session cookie to be HttpOnly. In browsers that support the HttpOnly feature (such as more recent versions of Internet Explorer and Firefox), this attribute can prevent the user's session cookie from being accessible to malicious client-side scripts that use document.cookie. This is not a complete solution, since HttpOnly is not supported by all browsers. More importantly, XMLHTTPRequest and other powerful browser technologies provide read access to HTTP headers, including the Set-Cookie header in which the HttpOnly flag is set."}, {"phase": "Implementation", "description": "Ensure that you perform input validation at well-defined interfaces within the application. This will help protect the application even if a component is reused or moved elsewhere."}, {"phase": "Architecture and Design", "description": "When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs."}, {"phase": "Operation", "description": "Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth."}, {"phase": "Implementation", "description": "Use a Content-Security-Policy Header for your application that is honored by a modern browser. Content Security Policy allows you to define specific execution scopes for attributes and elements that can be used to perform Cross-Site Scripting."}, {"phase": "Implementation", "description": "Deploy a Cross-Origin-Resource Sharing implementation to prevent your application's front-end from accessing unauthorized third-party URLs that may be part of an attacker's Cross-Site Scripting Attack"}], "categories": ["app_vulns", "owasp"], "variants": ["Persistent Cross-Site Scripting", "Reflected Cross-Site Scripting", "DOM-Based Cross Site Scripting"], "cwe": 79, "related_cwes": [80, 116], "risk": [{"consequence": "The most common attack performed with cross-site scripting involves the disclosure of information stored in user cookies. Typically, a malicious user will craft a client-side script, which -- when parsed by a web browser -- performs some activity (such as sending all site cookies to a given E-mail address). This script will be loaded and run by each user visiting the web site. Since the site requesting to run the script has access to the cookies in question, the malicious script does also.", "type": "Access_Control"}, {"consequence": "In some circumstances it may be possible to run arbitrary code on a victim's computer when cross-site scripting is combined with other flaws.", "type": "Integrity"}, {"consequence": "The consequence of an XSS attack is the same regardless of whether it is stored or reflected. The difference is in how the payload arrives at the server.", "type": "Confidentiality"}]}, "9": {"mitigations": [{"phase": "Architecture and Design", "description": "Certificates should be carefully managed and checked to assure that data are encrypted with the intended owner's public key."}, {"phase": "Implementation", "description": "Certificates should be deployed with strong CipherSuite Specs and Perfect Forward Secrecy for highest levels of protection"}], "name": "Improper Certificate Validation", "categories": ["app_vulns", "owasp"], "description": "The software does not validate, or incorrectly validates, a certificate.", "cwe": 295, "test-cases": [{"test": "Check for SSL/TLS implementation with automated tools", "tools": ["ssllabs.com", "testssl.sh", "sslyze", "sslscan", "nmap"], "name": "ssl-test"}, {"test": "Run Source Composition Scanners against the libraries being used by the application, to identify instances of misconfigured SSL/TLS Implementation or Plaintext Data Transmission", "tools": ["retirejs", "npm-audit", "owasp-dependency-checker", "blackduck", "whitesource", "snyk", "safety"], "type": "sca", "name": "source-composition-scanning"}, {"test": "Run Static Analysis tools to identify instances that relate to misconfigured SSL/TLS Implementation or Plaintext Data Transmission", "tools": ["checkmarx", "brakeman", "bandit", "pyt", "security-code-scan", "veracode", "nodejsscan", "coverity"], "type": "sast", "name": "static-analysis"}], "risk": [{"consequence": "Attacker may be able to leverage a weak SSL Implementation to compromise the master key/keying materials, thereby compromising the transmission of sensitive information", "type": "Confidentiality"}]}, "10": {"name": "Insecure Direct Object Reference - Primary Key", "risk": [{"consequence": "Access control checks for specific user data or functionality can be bypassed.", "type": "Access_Control"}, {"consequence": "Horizontal escalation of privilege is possible (one user can view/modify information of another user).", "type": "Access_Control"}, {"consequence": "Vertical escalation of privilege is possible if the user-controlled key is actually a flag that indicates administrator status, allowing the attacker to gain administrative access.", "type": "Access_Control"}], "test-cases": [{"test": "test for Insecure Direct Object References variants manually with pentesters, bug-bounty", "type": "manual", "name": "manual"}, {"test": "test for IDORs with Fuzzing with Automated tools", "type": "automated", "tools": ["burpsuite", "owasp-zap", "wfuzz", "mitmproxy"], "name": "fuzzing"}, {"test": "Run Static Analysis tools to identify instances of improper input validation and output encoding for Insecure Deserialization", "type": "sast", "tools": ["checkmarx", "brakeman", "bandit", "pyt", "security-code-scan", "veracode", "nodejsscan", "coverity"], "name": "static-analysis"}, {"test": "Run Source Composition Scanners against the libraries being used by the application, to identify instances of Insecure Deserialization", "type": "sca", "tools": ["retirejs", "npm-audit", "owasp-dependency-checker", "blackduck", "whitesource", "snyk", "safety"], "name": "source-composition-scanning"}], "mitigations": [{"phase": "Architecture and Design", "description": "For each and every data access, ensure that the user has sufficient privilege to access the record that is being requested."}, {"phase": "Architecture and Design", "description": "Make sure that the key that is used in the lookup of a specific user's record is not controllable externally by the user or that any tampering can be detected."}, {"phase": "Architecture and Design", "description": "Use encryption in order to make it more difficult to guess other legitimate values of the key or associate a digital signature with the key so that the server can verify that there has been no tampering."}], "categories": ["app_vulns"], "cwe": 639, "related_cwes": [284, 285], "description": "The system's authorization functionality does not prevent one user from gaining access to another user's data or record by modifying the key value identifying the data."}, "11": {"repo_id": "plaintext-transmission", "risk": [{"consequence": "Anyone can read the information by gaining access to the channel being used for communication.", "type": "Confidentiality"}], "categories": ["app_vulns", "owasp"], "name": "Plaintext transmission of sensitive data", "mitigations": [{"phase": "Architecture and Design", "description": "Encrypt the data with a reliable encryption scheme before transmitting."}, {"phase": "Implementation", "description": "When using web applications with SSL, use SSL for the entire session from login to logout, not just for the initial login page."}, {"phase": "Testing", "description": "Use tools and techniques that require manual (human) analysis, such as penetration testing, threat modeling, and interactive tools that allow the tester to record and modify an active session. These may be more effective than strictly automated techniques. This is especially the case with weaknesses that are related to design and business rules."}, {"phase": "Operation", "description": "Configure servers to use encrypted channels for communication, which may include SSL or other secure protocols."}], "test-cases": [{"test": "Check for SSL/TLS implementation with automated tools", "tools": ["ssllabs.com", "testssl.sh", "sslyze", "sslscan", "nmap"], "type": "discovery", "name": "ssl-test"}, {"test": "Run Source Composition Scanners against the libraries being used by the application, to identify instances of misconfigured SSL/TLS Implementation or Plaintext Data Transmission", "tools": ["retirejs", "npm-audit", "owasp-dependency-checker", "blackduck", "whitesource", "snyk", "safety"], "type": "sca", "name": "source-composition-scanning"}, {"test": "Run Static Analysis tools to identify instances that relate to misconfigured SSL/TLS Implementation or Plaintext Data Transmission", "tools": ["checkmarx", "brakeman", "bandit", "pyt", "security-code-scan", "veracode", "nodejsscan", "coverity"], "type": "sast", "name": "static-analysis"}], "cwe": 319, "related_cwes": [311], "description": "The software transmits sensitive or security-critical data in cleartext in a communication channel that can be sniffed by unauthorized actors."}, "12": {"repo_id": "aws_s3", "name": "Misconfigured AWS S3 Bucket", "risk": [{"consequence": "Unauthorized Users may gain access to files with sensitive information in the AWS S3 bucket(s)", "type": "Confidentiality"}, {"consequence": "Unauthorized Users may write/modify data in the AWS S3 bucket(s)", "type": "Integrity"}], "mitigations": [{"phase": "Implementation", "description": "Ensure that IAM Policies are set for AWS S3 to protect against public/unauthorized access to unauthorized users"}, {"phase": "Implementation", "description": "Consider implementation of encryption for data stored in AWS S3"}], "categories": ["cloud"], "cwe": 16, "test-cases": [{"test": "run automated vulnerability discovery tools to identify misconfigured AWS S3 buckets", "type": "discovery", "tools": ["scout2", "prowler", "weirdaal", "burpsuite"], "name": "automated-vulnerability-scanning"}, {"test": "test for misconfigured AWS S3 Buckets manually, as part of a Pentest or Bug-bounty", "type": "manual", "name": "manual"}], "description": "Misconfigured Amazon AWS S3 Bucket(s) might allow unauthorized users to read/write files in the specific S3 buckets"}, "13": {"test-cases": [{"test": "run automated vulnerability discovery tools and bruteforce against the application", "tools": ["zap", "burpsuite", "arachni", "acunetix", "netsparker", "appspider", "w3af"], "type": "discovery", "name": "automated-vulnerability-scanning"}], "repo_id": "password-bruteforce", "name": "Bruteforce Passwords", "cwe": 307, "mitigations": [{"phase": "Architecture and Design", "description": "Ensure that users are locked out for a certain timeframe/till administrator's intervention when multiple authentication attempts are encountered."}, {"phase": "Architecture and Design", "description": "Log invalid access attempts to ensure that potentially malicious bruteforce attempts are logged"}], "categories": ["attack"], "description": "The application allows multiple/consecutive attempts at authentication (bruteforce)."}, "14": {"repo_id": "sql_injection", "name": "SQL Injection", "risk": [{"consequence": "Since SQL databases generally hold sensitive data, loss of confidentiality is a frequent problem with SQL injection vulnerabilities.", "type": "Confidentiality"}, {"consequence": "If poor SQL commands are used to check user names and passwords, it may be possible to connect to a system as another user with no previous knowledge of the password.", "type": "Access_Control"}, {"consequence": "If authorization information is held in a SQL database, it may be possible to change this information through the successful exploitation of a SQL injection vulnerability.", "type": "Access_Control"}, {"consequence": "Just as it may be possible to read sensitive information, it is also possible to make changes or even delete this information with a SQL injection attack.", "type": "Integrity"}], "mitigations": [{"phase": "Architecture and Design", "description": "Consider using ORMs (Object to Relation Mappers) to protect against SQL Injection. Nearly all of them perform Parameterized Queries and Query Encoding.", "strategy": "Libraries or Frameworks"}, {"phase": "Implementation", "description": "Process SQL queries using prepared statements, parameterized queries. Do not dynamically construct and execute query strings within these features using \"exec\" or similar functionality, since this may re-introduce the possibility of SQL injection."}, {"phase": "Architecture and Design", "description": "Specifically, follow the principle of least privilege when creating user accounts to a SQL database. The database users should only have the minimum privileges necessary to use their account."}, {"phase": "Implementation", "description": "In the context of SQL Injection, error messages revealing the structure of a SQL query can help attackers tailor successful attack strings."}, {"phase": "Operation", "description": "Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed,as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth."}], "categories": ["app_vulns", "owasp"], "variants": ["Blind SQL Injection", "Time-Based SQL Injection", "Union-Based SQL Injection", "Error-Based SQL Injection", "Second-Order SQL Injection"], "cwe": 89, "test-cases": [{"test": "run automated vulnerability discovery tools and its Injection payloads against the application", "type": "discovery", "tools": ["zap", "burpsuite", "arachni", "acunetix", "netsparker", "appspider", "w3af"], "name": "automated-vulnerability-scanning"}, {"test": "test for SQL Injection variants manually with pentesters, bug-bounty", "type": "manual", "name": "manual"}, {"test": "Run exploit tools to identify and exploit SQL Injections in the application", "tools": ["sqlmap", "netsparker", "jsqli"], "type": "exploit", "name": "exploit"}, {"test": "Run Source Composition Scanners against the libraries being used by the application, to identify instances of SQL Injection", "type": "sca", "tools": ["retirejs", "npm-audit", "owasp-dependency-checker", "blackduck", "whitesource", "snyk", "safety"], "name": "source-composition-scanning"}, {"test": "Run Static Analysis tools to identify instances of dynamic queries or stored procedures that are vulnerable to SQL Injection", "type": "sast", "tools": ["checkmarx", "brakeman", "bandit", "pyt", "security-code-scan", "veracode", "nodejsscan", "coverity"], "name": "static-analysis"}], "description": "The software constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component."}, "15": {"repo_id": "insecure_deserialization", "risk": [{"consequence": "The consequences can vary widely, because it depends on which objects or methods are being deserialized, and how they are used."}, {"consequence": "Attackers can modify unexpected objects or data that was assumed to be safe from modification.", "type": "Integrity"}, {"consequence": "If a function is making an assumption on when to terminate, based on a sentry in a string, it could easily never terminate.", "type": "Availability"}, {"consequence": "Code could potentially make the assumption that information in the deserialized object is valid. Functions that make this dangerous assumption could be exploited.", "type": "Authorization"}], "name": "Insecure Deserialization", "mitigations": [{"phase": "Architecture and Design", "description": "If available, use the signing/sealing features of the programming language to assure that deserialized data has not been tainted. For example, a hash-based message authentication code (HMAC) could be used to ensure that data has not been modified."}, {"phase": "Implementation", "description": "When deserializing data, populate a new object rather than just deserializing. The result is that the data flows through safe input validation and that the functions are safe."}, {"phase": "Architecture and Design", "description": "An attempt to serialize and then deserialize a class containing transient fields will result in NULLs where the transient data should be. This is an excellent way to prevent time, environment-based, or sensitive variables from being carried over and used improperly."}, {"phase": "Implementation", "description": "Avoid having unnecessary types or gadgets available that can be leveraged for malicious ends. This limits the potential for unintended or unauthorized types and gadgets to be leveraged by the attacker. Whitelist acceptable classes. Note- new gadgets are constantly being discovered, so this alone is not a sufficient mitigation."}], "test-cases": [{"test": "run automated vulnerability discovery tools and its Insecure Deserialization payloads against the application", "tools": ["zap", "burpsuite", "arachni", "acunetix", "netsparker", "appspider", "w3af"], "type": "discovery", "name": "automated-vulnerability-scanning"}, {"test": "test for Insecure Deserialization variants manually with pentesters, bug-bounty", "type": "manual", "name": "manual"}, {"test": "Run Static Analysis tools to identify instances of improper input validation and output encoding for Insecure Deserialization", "tools": ["checkmarx", "brakeman", "bandit", "pyt", "security-code-scan", "veracode", "nodejsscan", "coverity"], "type": "sast", "name": "static-analysis"}, {"test": "Run Source Composition Scanners against the libraries being used by the application, to identify instances of Insecure Deserialization", "tools": ["retirejs", "npm-audit", "owasp-dependency-checker", "blackduck", "whitesource", "snyk", "safety"], "type": "sca", "name": "source-composition-scanning"}], "cwe": 502, "categories": ["app_vulns", "owasp"], "description": "The application deserializes untrusted data without sufficiently verifying that the resulting data will be valid."}, "16": {"repo_id": "xxe", "risk": [{"consequence": "If the attacker is able to include a crafted DTD and a default entity resolver is enabled, the attacker may be able to access arbitrary files on the system.", "type": "Confidentiality"}, {"consequence": "The DTD may include arbitrary HTTP requests that the server may execute. This could lead to other attacks leveraging the server's trust relationship with other entities.", "type": "Integrity"}, {"consequence": "The software could consume excessive CPU cycles or memory using a URI that points to a large file, or a device that always returns data such as /dev/random. Alternately, the URI could reference a file that contains many nested or recursive entity references to further slow down parsing.", "type": "Availability"}], "name": "XML External Entities", "mitigations": [{"phase": "Implementation", "description": "XML parsers and validators must be configured to disable external entity expansion, general entities and parameter entity resolution"}], "test-cases": [{"test": "run automated vulnerability discovery tools and its XXE payloads against the application", "type": "discovery", "tools": ["zap", "burpsuite", "arachni", "acunetix", "netsparker", "appspider", "w3af"], "name": "automated-vulnerability-scanning"}, {"test": "test for XXE variants manually with pentesters, bug-bounty", "type": "manual", "name": "manual"}, {"test": "Run Source Composition Scanners against the libraries being used by the application, to identify instances of XXE", "type": "sca", "tools": ["retirejs", "npm-audit", "owasp-dependency-checker", "blackduck", "whitesource", "snyk", "safety"], "name": "source-composition-scanning"}, {"test": "Run Static Analysis tools to identify instances of dynamic queries or stored procedures that are vulnerable to XXE", "type": "sast", "tools": ["checkmarx", "brakeman", "bandit", "pyt", "security-code-scan", "veracode", "nodejsscan", "coverity"], "name": "static-analysis"}], "cwe": 611, "categories": ["app_vulns", "owasp"], "description": "The software processes an XML document that can contain XML entities with URIs that resolve to documents outside of the intended sphere of control, causing the product to embed incorrect documents into its output."}, "17": {"repo_id": "code_injection", "risk": [{"consequence": "In some cases, injectable code controls authentication; this may lead to a remote vulnerability.", "type": "Access_Control"}, {"consequence": "Injected code can access resources that the attacker is directly prevented from accessing.", "type": "Access_Control"}, {"consequence": "Code injection attacks can lead to loss of data integrity in nearly all cases as the control-plane data injected is always incidental to data recall or writing. Additionally, code injection can often result in the execution of arbitrary code.", "type": "Integrity"}, {"consequence": "Often the actions performed by injected control code are unlogged.", "type": "Non-Repudiation"}], "categories": ["app_vulns", "owasp"], "name": "Code Injection", "mitigations": [{"phase": "Architecture and Design", "description": "Refactor your program so that you do not have to dynamically generate code."}, {"phase": "Implementation", "description": "To reduce the likelihood of code injection, use stringent whitelists that limit which constructs are allowed. If you are dynamically constructing code that invokes a function, then verifying that the input is alphanumeric might be insufficient. An attacker might still be able to reference a dangerous function that you did not intend to allow, such as system(), exec(), or exit()."}, {"phase": "Testing", "description": "Use automated static analysis tools that target this type of weakness. Many modern techniques use data flow analysis to minimize the number of false positives. This is not a perfect solution, since 100% accuracy and coverage are not feasible."}, {"phase": "Testing", "description": "Use dynamic tools and techniques that interact with the software using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The software's operation may slow down, but it should not become unstable, crash, or generate incorrect results."}, {"phase": "Operation", "description": "Run the code in an environment that performs automatic taint propagation and prevents any command execution that uses tainted variables, such as Perl's \"-T\" switch. This will force the program to perform validation steps that remove the taint, although you must be careful to correctly validate your inputs so that you do not accidentally mark dangerous inputs as untainted (see CWE-183 and CWE-184)."}, {"phase": "Testing", "description": "Identify vulnerabilities in underlying libraries with Source Composition Scanning"}, {"phase": "Implementation", "description": "Consider using low-logic templating systems, if you are using Templating Frameworks. Low-Logic Templating Systems like Mustache cannot expand objects and data-structures, thereby ensuring that remote code execution through Template Variables, does not happen"}], "test-cases": [{"test": "run automated vulnerability discovery tools and its Injection payloads against the application", "tools": ["zap", "burpsuite", "arachni", "acunetix", "netsparker", "appspider", "w3af"], "type": "discovery", "name": "automated-vulnerability-scanning"}, {"test": "test for Code Injection variants manually with pentesters, bug-bounty", "type": "manual", "name": "manual"}, {"test": "Run exploit tools to identify and exploit Code Injections in the application", "type": "exploit", "tools": ["sqlmap", "netsparker", "jsqli"], "name": "exploit"}, {"test": "Run Source Composition Scanners against the libraries being used by the application, to identify instances of Code Injection", "tools": ["retirejs", "npm-audit", "owasp-dependency-checker", "blackduck", "whitesource", "snyk", "safety"], "type": "sca", "name": "source-composition-scanning"}, {"test": "Run Static Analysis tools to identify instances of dynamic queries or stored procedures that are vulnerable to Code Injection", "tools": ["checkmarx", "brakeman", "bandit", "pyt", "security-code-scan", "veracode", "nodejsscan", "coverity"], "type": "sast", "name": "static-analysis"}], "variants": ["Server-Side Eval Injection", "Server-Side Template Injection"], "cwe": 94, "related_cwes": [95, 96], "description": "The software constructs all or part of a code segment using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the syntax or behavior of the intended code segment."}, "18": {"repo_id": "xss", "risk": [{"consequence": "The most common attack performed with cross-site scripting involves the disclosure of information stored in user cookies. Typically, a malicious user will craft a client-side script, which -- when parsed by a web browser -- performs some activity (such as sending all site cookies to a given E-mail address). This script will be loaded and run by each user visiting the web site. Since the site requesting to run the script has access to the cookies in question, the malicious script does also.", "type": "Access_Control"}, {"consequence": "In some circumstances it may be possible to run arbitrary code on a victim's computer when cross-site scripting is combined with other flaws.", "type": "Integrity"}, {"consequence": "The consequence of an XSS attack is the same regardless of whether it is stored or reflected. The difference is in how the payload arrives at the server.", "type": "Confidentiality"}], "name": "Cross-Site Scripting", "test-cases": [{"test": "run automated vulnerability discovery tools and its XSS payloads against the application", "type": "discovery", "tools": ["zap", "burpsuite", "arachni", "acunetix", "netsparker", "appspider", "w3af"], "name": "automated-vulnerability-scanning"}, {"test": "test for XSS variants manually with pentesters, bug-bounty", "type": "manual", "name": "manual"}, {"test": "Look for Content Security Policy headers in the Application and validate if the application enforces content-security-policy headers with optimal efficacy", "type": "recon", "name": "content-security-policy"}, {"test": "Look for Cross-Origin Resource Sharing to ensure that the application is unable to make calls to URLs outside a specific set of whitelisted URLs and domains", "type": "discovery", "name": "cors"}, {"test": "Run Static Analysis tools to identify instances of improper input validation and output encoding for Cross-Site Scripting", "type": "sast", "tools": ["checkmarx", "brakeman", "bandit", "pyt", "security-code-scan", "veracode", "nodejsscan", "coverity"], "name": "static-analysis"}, {"test": "Run Source Composition Scanners against the libraries being used by the application, to identify instances of Cross-Site Scripting", "type": "sca", "tools": ["retirejs", "npm-audit", "owasp-dependency-checker", "blackduck", "whitesource", "snyk", "safety"], "name": "source-composition-scanning"}], "mitigations": [{"phase": "Architecture and Design", "description": "Examples of libraries and frameworks that make it easier to generate properly encoded output include Microsoft's Anti-XSS library, the OWASP ESAPI Encoding module, and Apache Wicket."}, {"phase": "Architecture and Design", "description": "Understand all the potential areas where untrusted inputs can enter your software. Parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, filenames, databases, and any external systems that provide data to the application. Remember that such inputs may be obtained indirectly through API calls."}, {"phase": "Architecture and Design", "description": "For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side."}, {"phase": "Architecture and Design", "description": "If available, use structured mechanisms that automatically enforce the separation between data and code. These mechanisms may be able to provide the relevant quoting, encoding, and validation automatically, instead of relying on the developer to provide this capability at every point where output is generated."}, {"phase": "Implementation", "description": "The problem of inconsistent output encodings often arises in web pages. If an encoding is not specified in an HTTP header, web browsers often guess about which encoding is being used. This can open up the browser to subtle XSS attacks."}, {"phase": "Implementation", "description": "To help mitigate XSS attacks against the user's session cookie, set the session cookie to be HttpOnly. In browsers that support the HttpOnly feature (such as more recent versions of Internet Explorer and Firefox), this attribute can prevent the user's session cookie from being accessible to malicious client-side scripts that use document.cookie. This is not a complete solution, since HttpOnly is not supported by all browsers. More importantly, XMLHTTPRequest and other powerful browser technologies provide read access to HTTP headers, including the Set-Cookie header in which the HttpOnly flag is set."}, {"phase": "Implementation", "description": "Ensure that you perform input validation at well-defined interfaces within the application. This will help protect the application even if a component is reused or moved elsewhere."}, {"phase": "Architecture and Design", "description": "When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs."}, {"phase": "Operation", "description": "Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth."}, {"phase": "Implementation", "description": "Use a Content-Security-Policy Header for your application that is honored by a modern browser. Content Security Policy allows you to define specific execution scopes for attributes and elements that can be used to perform Cross-Site Scripting."}, {"phase": "Implementation", "description": "Deploy a Cross-Origin-Resource Sharing implementation to prevent your application's front-end from accessing unauthorized third-party URLs that may be part of an attacker's Cross-Site Scripting Attack"}], "categories": ["app_vulns", "owasp"], "variants": ["Persistent Cross-Site Scripting", "Reflected Cross-Site Scripting", "DOM-Based Cross Site Scripting"], "cwe": 79, "related_cwes": [80, 116], "description": "The software does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users."}, "19": {"repo_id": "cert_validation", "risk": [{"consequence": "Attacker may be able to leverage a weak SSL Implementation to compromise the master key/keying materials, thereby compromising the transmission of sensitive information", "type": "Confidentiality"}], "name": "Improper Certificate Validation", "mitigations": [{"phase": "Architecture and Design", "description": "Certificates should be carefully managed and checked to assure that data are encrypted with the intended owner's public key."}, {"phase": "Implementation", "description": "Certificates should be deployed with strong CipherSuite Specs and Perfect Forward Secrecy for highest levels of protection"}], "test-cases": [{"test": "Check for SSL/TLS implementation with automated tools", "tools": ["ssllabs.com", "testssl.sh", "sslyze", "sslscan", "nmap"], "name": "ssl-test"}, {"test": "Run Source Composition Scanners against the libraries being used by the application, to identify instances of misconfigured SSL/TLS Implementation or Plaintext Data Transmission", "tools": ["retirejs", "npm-audit", "owasp-dependency-checker", "blackduck", "whitesource", "snyk", "safety"], "type": "sca", "name": "source-composition-scanning"}, {"test": "Run Static Analysis tools to identify instances that relate to misconfigured SSL/TLS Implementation or Plaintext Data Transmission", "tools": ["checkmarx", "brakeman", "bandit", "pyt", "security-code-scan", "veracode", "nodejsscan", "coverity"], "type": "sast", "name": "static-analysis"}], "cwe": 295, "categories": ["app_vulns", "owasp"], "description": "The software does not validate, or incorrectly validates, a certificate."}, "20": {"repo_id": "idor_pk", "name": "Insecure Direct Object Reference - Primary Key", "risk": [{"consequence": "Access control checks for specific user data or functionality can be bypassed.", "type": "Access_Control"}, {"consequence": "Horizontal escalation of privilege is possible (one user can view/modify information of another user).", "type": "Access_Control"}, {"consequence": "Vertical escalation of privilege is possible if the user-controlled key is actually a flag that indicates administrator status, allowing the attacker to gain administrative access.", "type": "Access_Control"}], "test-cases": [{"test": "test for Insecure Direct Object References variants manually with pentesters, bug-bounty", "type": "manual", "name": "manual"}, {"test": "test for IDORs with Fuzzing with Automated tools", "type": "automated", "tools": ["burpsuite", "owasp-zap", "wfuzz", "mitmproxy"], "name": "fuzzing"}, {"test": "Run Static Analysis tools to identify instances of improper input validation and output encoding for Insecure Deserialization", "type": "sast", "tools": ["checkmarx", "brakeman", "bandit", "pyt", "security-code-scan", "veracode", "nodejsscan", "coverity"], "name": "static-analysis"}, {"test": "Run Source Composition Scanners against the libraries being used by the application, to identify instances of Insecure Deserialization", "type": "sca", "tools": ["retirejs", "npm-audit", "owasp-dependency-checker", "blackduck", "whitesource", "snyk", "safety"], "name": "source-composition-scanning"}], "mitigations": [{"phase": "Architecture and Design", "description": "For each and every data access, ensure that the user has sufficient privilege to access the record that is being requested."}, {"phase": "Architecture and Design", "description": "Make sure that the key that is used in the lookup of a specific user's record is not controllable externally by the user or that any tampering can be detected."}, {"phase": "Architecture and Design", "description": "Use encryption in order to make it more difficult to guess other legitimate values of the key or associate a digital signature with the key so that the server can verify that there has been no tampering."}], "categories": ["app_vulns"], "cwe": 639, "related_cwes": [284, 285], "description": "The system's authorization functionality does not prevent one user from gaining access to another user's data or record by modifying the key value identifying the data."}}}